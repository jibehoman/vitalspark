package pbm.debugutil;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

public class KnownThreadsManager {
	
	private static final String KNOWN_FILE_HEADER = "# Known Threads File";
	
	List<KnownThread> threads;
	
    // Determines whether thread names should be taken into
    // account in comparisons related to known threads - can be used
	// for thread dumps that don't include thread names, e.g. 'jstack -F'
    boolean includeThreadNames = true;

    // Determines whether thread state information should be taken into
	// account in comparisons related to known threads
	boolean includeThreadStates = true;
	
	public KnownThreadsManager() {
		threads = new LinkedList<KnownThread>();
		
	}
	
	public void load(File threadsFile) throws IOException, UnexpectedFormatException {
		
		LogReader reader = new SimpleReader(threadsFile);
		
		String line = reader.getNextLine();
		
		if (!line.startsWith(KNOWN_FILE_HEADER)) {
			throw new UnexpectedFormatException("Expected '" + KNOWN_FILE_HEADER + "...', found: '" + Util.truncateString(line, 34) + "'");
		}
		
		line = reader.getNextLine();
		
		while (line != null) {
			
			line = line.trim();
			
			// Ignore empty lines and comments starting with '#'
			if (line.length() > 0 && line.charAt(0) != '#') {

				KnownThread thread = new KnownThread(line);

				boolean cont = true;
				while (cont) {
					line = reader.getNextLine();
					if (line != null && line.trim().length() > 0 && (line.startsWith("  ") || (line.startsWith("\t")))) {
						thread.addToStack(line.trim());
					} else {
						cont = false;
					}
				}
				
				threads.add(thread);
				
			} else {
				line = reader.getNextLine();
			}
			
		}		
	}

	public void save(File threadsFile) throws IOException {
		// Sort before saving file
		Collections.sort(threads);
		
		PrintStream outstream = null;
		
		try {
			outstream = new PrintStream(threadsFile);
	
			outstream.println(KNOWN_FILE_HEADER + " generated by AnalyseThreads " + AnalyseThreads.VERSION_STRING);
		
			for (KnownThread t : threads) {
				outstream.println("");
				t.printThread(outstream);
			}
			
		} catch (IOException ioe) {
			throw ioe;
		} finally {	
			if (outstream != null) outstream.close();
		}
	}
	
	// Add the given thread to the known threads if not already present	
	public void add(NormalisedThread t) {
		if (findMatch(t) == null) {
			threads.add(new KnownThread(t));
		}
	}
	
	// Remove the given thread from the known threads if present
	public void remove(NormalisedThread t) {
		KnownThread match = findMatch(t);
		if (match != null) {
			threads.remove(match);
		}
	}	
	
	public void clear() {
		threads.clear();
	}
	
	public int getCount() {
		return threads.size();
	}
	
    public boolean getIncludeThreadNames() {
        return includeThreadNames;
    }

    public void setIncludeThreadNames(boolean includeThreadNames) {
        this.includeThreadNames = includeThreadNames;
    }
    
    public boolean getIncludeThreadStates() {
		return includeThreadStates;
	}

	public void setIncludeThreadStates(boolean includeThreadStates) {
		this.includeThreadStates = includeThreadStates;
	}	

	public KnownThread findMatch(NormalisedThread normalisedThread) {
		
		for (KnownThread t : threads) {
			if (t.matches(normalisedThread, false, includeThreadStates)) return t;
		}

		return null;
	}
	
}
